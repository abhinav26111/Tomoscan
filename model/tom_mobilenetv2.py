# -*- coding: utf-8 -*-
"""tom_mobilenetV2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U5Rq2_f_voE8LPHJvr7t_g_DkI_rsSM5
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES
# TO THE CORRECT LOCATION (/kaggle/input) IN YOUR NOTEBOOK,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.

import os
import sys
from tempfile import NamedTemporaryFile
from urllib.request import urlopen
from urllib.parse import unquote, urlparse
from urllib.error import HTTPError
from zipfile import ZipFile
import tarfile
import shutil

CHUNK_SIZE = 40960
DATA_SOURCE_MAPPING = 'tomato:https%3A%2F%2Fstorage.googleapis.com%2Fkaggle-data-sets%2F259770%2F544347%2Fbundle%2Farchive.zip%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com%252F20240420%252Fauto%252Fstorage%252Fgoog4_request%26X-Goog-Date%3D20240420T175434Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D8b4a7ffaba3d22a648c37233555f33448b23089d4a572f045f40da91fc61bc59b28e7391ec927b5cfc97d47b1ba15ce2c76e677854fdb09cc57359681c29bad39e9b661a83264881b1d1a2538d32a87b944866d71736a5b16d8adfa3b709c552a2c01091eb9487f9857d6385dde2c57442eec237a69b225cec8e18566da2ae246a9e08c31c7318a41bcf73c6a83aedc2f057d06db54ecbdf35e0ac30408169773413d59d03f7e8d071516773228c208ef0b627f5764a39114cb990f87e38d26acadb53e032f6403873c77ac80dd5cb094f0a6421f630d8a7bd419692adec0dadf9fe23ce891a3e5a8d6b406d40fbec4c00944453779f311ca005a4646293719b'

KAGGLE_INPUT_PATH='/kaggle/input'
KAGGLE_WORKING_PATH='/kaggle/working'
KAGGLE_SYMLINK='kaggle'

!umount /kaggle/input/ 2> /dev/null
shutil.rmtree('/kaggle/input', ignore_errors=True)
os.makedirs(KAGGLE_INPUT_PATH, 0o777, exist_ok=True)
os.makedirs(KAGGLE_WORKING_PATH, 0o777, exist_ok=True)

try:
  os.symlink(KAGGLE_INPUT_PATH, os.path.join("..", 'input'), target_is_directory=True)
except FileExistsError:
  pass
try:
  os.symlink(KAGGLE_WORKING_PATH, os.path.join("..", 'working'), target_is_directory=True)
except FileExistsError:
  pass

for data_source_mapping in DATA_SOURCE_MAPPING.split(','):
    directory, download_url_encoded = data_source_mapping.split(':')
    download_url = unquote(download_url_encoded)
    filename = urlparse(download_url).path
    destination_path = os.path.join(KAGGLE_INPUT_PATH, directory)
    try:
        with urlopen(download_url) as fileres, NamedTemporaryFile() as tfile:
            total_length = fileres.headers['content-length']
            print(f'Downloading {directory}, {total_length} bytes compressed')
            dl = 0
            data = fileres.read(CHUNK_SIZE)
            while len(data) > 0:
                dl += len(data)
                tfile.write(data)
                done = int(50 * dl / int(total_length))
                sys.stdout.write(f"\r[{'=' * done}{' ' * (50-done)}] {dl} bytes downloaded")
                sys.stdout.flush()
                data = fileres.read(CHUNK_SIZE)
            if filename.endswith('.zip'):
              with ZipFile(tfile) as zfile:
                zfile.extractall(destination_path)
            else:
              with tarfile.open(tfile.name) as tarfile:
                tarfile.extractall(destination_path)
            print(f'\nDownloaded and uncompressed: {directory}')
    except HTTPError as e:
        print(f'Failed to load (likely expired) {download_url} to path {destination_path}')
        continue
    except OSError as e:
        print(f'Failed to load {download_url} to path {destination_path}')
        continue

print('Data source import complete.')

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import os

path = "../input/tomato/New Plant Diseases Dataset(Augmented)"
os.listdir(path)

train_path = os.path.join(path, "train")
print(os.listdir(train_path))
print("*"*100)
test_path = os.path.join(path, "valid")
print(os.listdir(test_path))

from glob import glob
folders = glob("../input/tomato/New Plant Diseases Dataset(Augmented)/train/*")
folders

import matplotlib.pyplot as plt
plt.imshow(plt.imread("../input/tomato/New Plant Diseases Dataset(Augmented)/train/Tomato___Bacterial_spot/00416648-be6e-4bd4-bc8d-82f43f8a7240___GCREC_Bact.Sp 3110.JPG"))
plt.title("Bacterial Spot")

train_dir = "/kaggle/input/tomato/New Plant Diseases Dataset(Augmented)/train/"
val_dir = "/kaggle/input/tomato/New Plant Diseases Dataset(Augmented)/valid/"

class_names = sorted(os.listdir(train_dir))
class_names

class_dis = [len(os.listdir(train_dir + name)) for name in class_names]
class_dis

class_names1 = sorted(os.listdir(val_dir))
class_names1

class_dis1 = [len(os.listdir(val_dir + name)) for name in class_names]
class_dis1

import plotly.express as px
fig = px.pie(names=class_names, values=class_dis, hole=0.3)
fig.update_layout({"title":{"text":"Distibution of classes", "x":0.50}})
fig.show()

from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.layers import GlobalAveragePooling2D, Dense
from tensorflow.keras.models import Model

SIZE = [128, 128]

# Load MobileNetV2 model without the top (classification) layer
base_model = MobileNetV2(weights='imagenet', include_top=False, input_shape=(128, 128, 3))

# Freeze the pre-trained layers
for layer in base_model.layers:
    layer.trainable = False

# Add custom classification layers
x = GlobalAveragePooling2D()(base_model.output)
x = Dense(256, activation='relu')(x)
predictions = Dense(len(folders), activation='softmax')(x)  # Assuming len(folders) is the number of classes
model_mobile = Model(inputs=base_model.input, outputs=predictions)

# Summary of the model architecture
model_mobile.summary()

# Compile the model
model_mobile.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Data Augmentation
train_datagen_mobile = ImageDataGenerator(rescale=1./255)
test_datagen_mobile = ImageDataGenerator(rescale=1./255)

trainning_set_mobile = train_datagen_mobile.flow_from_directory(train_path,
                                                                 target_size=(128, 128),
                                                                 batch_size=16,
                                                                 class_mode="categorical",
                                                                 shuffle=True)

testing_set_mobile = test_datagen_mobile.flow_from_directory(test_path,
                                                              target_size=(128, 128),
                                                              batch_size=16,
                                                              class_mode="categorical",
                                                              shuffle=False)

import tensorflow as tf
callback = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=20)

# Train the model
r_mobile = model_mobile.fit(trainning_set_mobile,
                                      validation_data=testing_set_mobile,
                                      epochs=50,
                                      callbacks=[callback])

import matplotlib.pyplot as plt
accuracy = r_mobile.history['accuracy']
val_accuracy = r_mobile.history['val_accuracy']
loss = r_mobile.history['loss']
val_loss = r_mobile.history['val_loss']
epochs = range(len(accuracy))
plt.title("Training and Validation Accuracy")
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.plot(epochs, accuracy, "b", label="trainning accuracy")
plt.plot(epochs, val_accuracy, "r", label="validation accuracy")
plt.legend()
plt.show()

plt.title('Training and Validation Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.plot(epochs, loss, "b", label="trainning loss")
plt.plot(epochs, val_loss, "r", label="validation loss")
plt.legend()
plt.show()

test_img = plt.imread("../input/tomato/New Plant Diseases Dataset(Augmented)/train/Tomato___Bacterial_spot/00416648-be6e-4bd4-bc8d-82f43f8a7240___GCREC_Bact.Sp 3110.JPG")

plt.imshow(test_img)

model_mobile.save("mobnet.model")

train_loss, train_acc = model_mobile.evaluate(trainning_set_mobile)
print("Training Accuracy: {:.2f}%".format(train_acc*100))

test_loss, test_acc = model_mobile.evaluate(testing_set_mobile)
print("Testing Accuracy: {:.2f}%".format(test_acc*100))

import cv2
import tensorflow as tf
def prepare(filepath):
    img_array = cv2.imread(filepath, cv2.IMREAD_COLOR)
    img_array = img_array / 255
    new_array = cv2.resize(img_array, (128, 128))
    return new_array.reshape(-1, 128, 128, 3)

model = tf.keras.models.load_model("mobnet.model")

class_dict = trainning_set_mobile.class_indices
class_dict

def prediction_cls(prediction):
    for key, clss in class_dict.items():
        if np.argmax(prediction) == clss:
            details = details_dict[key]
            return key, details

import numpy as np
details_dict = {
    'Tomato___Bacterial_spot': "The tomato chosen has Bacterial spot (Caused by Xanthomonas spp.). \nManagement: Use fertilizers low in nitrogen, as excessive nitrogen can encourage lush growth that is more susceptible to bacterial infections. Focus on potassium-rich fertilizers to help strengthen cell walls and improve disease resistance.",
    'Tomato___Early_blight':  "The tomato chosen has Early blight (Caused by the fungus Alternaria solani). \nManagement: Avoid excessive nitrogen and focus on balanced fertilization to support overall plant health.",
    'Tomato___Late_blight':"The tomato chosen has Late blight (Caused by the fungus Phytophthora infestans). \nManagement: Maintain balanced nutrition to support plant health and avoid excessive nitrogen, which can promote lush growth more susceptible to fungal infections.",
    'Tomato___Leaf_mould':"The tomato chosen has Leaf mold (Caused by the fungus Fulvia fulva). \nManagement: Balanced fertilization can help maintain plant vigor and resilience. Adequate potassium levels can improve disease resistance.",
    'Tomato___Septoria_leaf_spot' :"The tomato chosen has Septoria leaf spot (Caused by the fungus Septoria lycopersici). \nManagement: Balanced fertilization with adequate potassium levels can help improve disease resistance. Avoid excessive nitrogen, which can promote lush foliage more susceptible to fungal infections.",
    'Tomato___Spider_mites Two-spotted_spider_mite':"The tomato chosen has Two-spotted spider mite (Tetranychus urticae). \nManagement: While not a disease, maintaining proper fertilization can help keep plants healthy and better able to withstand pest infestations. Avoid over-fertilization, as this can attract mites.",
    'Tomato___Target_spot':"The tomato chosen has Target spot (Caused by the fungus Corynespora cassiicola). \nManagement: Maintain balanced nutrition to support plant health. Avoid excessive nitrogen, as it can promote lush foliage that is more susceptible to fungal diseases.",
    'Tomato___Tomato_Yellow_Leaf_Curl_Virus': "The tomato chosen has Yellow leaf curl virus (Caused by various Begomovirus species). \nManagement: Ensure the plant's nutritional needs are met with balanced fertilization to support its overall health and vigor.",
    'Tomato___Tomato_mosaic_virus': "The tomato chosen has Tomato mosaic virus (Caused by virus). \nManagement: Use a balanced fertilizer with moderate levels of nitrogen, phosphorus, and potassium to support overall plant health and vigor.",
    'Tomato___healthy':"The image of the tomato leaf chosen is healthy."

}

prediction = model.predict([prepare("../input/tomato/New Plant Diseases Dataset(Augmented)/valid/Tomato___healthy/0a334ae6-bea3-4453-b200-85e082794d56___GH_HL Leaf 310.1_flipTB.JPG")])[0]
predicted_class, details = prediction_cls(prediction)
print("Predicted class:", predicted_class)
print("Details:", details)

prediction = model.predict([prepare("../input/tomato/New Plant Diseases Dataset(Augmented)/valid/Tomato___Late_blight/005e3b43-9050-47da-9498-f9ecdcc703b3___RS_Late.B 5104.JPG")])
predicted_class, details = prediction_cls(prediction)
print("Predicted class:", predicted_class)
print("Details:", details)

prediction = model.predict([prepare("../input/tomato/New Plant Diseases Dataset(Augmented)/valid/Tomato___Early_blight/004cbe60-8ff9-4965-92df-e86694d5e9ba___RS_Erly.B 8253.JPG")])
predicted_class, details = prediction_cls(prediction)
print("Predicted class:", predicted_class)
print("Details:", details)

from sklearn.metrics import precision_score, recall_score, f1_score, confusion_matrix

# Predict the classes of the test set
y_pred = model_mobile.predict(testing_set_mobile)
y_pred_classes = np.argmax(y_pred, axis=1)

precision = precision_score(testing_set_mobile.classes, y_pred_classes, average='weighted')
recall = recall_score(testing_set_mobile.classes, y_pred_classes, average='weighted')
f1 = f1_score(testing_set_mobile.classes, y_pred_classes, average='weighted')
confusion = confusion_matrix(testing_set_mobile.classes, y_pred_classes)

# Print the results
print("Precision: {:.2f}%".format(precision * 100))
print("Recall: {:.2f}%".format(recall * 100))
print("F1 score: {:.2f}%".format(f1 * 100))
print("Confusion matrix:")
print(confusion)

!pip install tabulate

from tabulate import tabulate

# Calculate precision, recall, and F1 score for each class
class_precision = precision_score(testing_set_mobile.classes, y_pred_classes, average=None)
class_recall = recall_score(testing_set_mobile.classes, y_pred_classes, average=None)
class_f1 = f1_score(testing_set_mobile.classes, y_pred_classes, average=None)

# Create a list of lists to store the table data
table_data = [['Class', 'Precision', 'Recall', 'F1 score']]

# Add the class-wise metrics to the table data
for i in range(len(class_names)):
    table_data.append([class_names[i], f"{class_precision[i] * 100:.2f}", f"{class_recall[i] * 100:.2f}", f"{class_f1[i] * 100:.2f}"])

# Print the table
print("Class-wise Precision, Recall, and F1 score:")
print(tabulate(table_data, tablefmt='grid'))

import seaborn as sns
import matplotlib.pyplot as plt

# Calculate the confusion matrix
confusion = confusion_matrix(testing_set_mobile.classes, y_pred_classes)

# Plot the confusion matrix with colors
plt.figure(figsize=(10, 8))
sns.heatmap(confusion, annot=True, cmap='Blues', fmt='g')
plt.xlabel('Predicted labels')
plt.ylabel('True labels')
plt.title('Confusion Matrix')
plt.show()

from sklearn.metrics import classification_report

# Print the classification report
print(classification_report(testing_set_mobile.classes, y_pred_classes, target_names=class_names))

# Save the model to a HDF5 file
model_mobile.save('model_mobnet.h5')

